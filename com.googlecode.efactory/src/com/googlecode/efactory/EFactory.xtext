grammar com.googlecode.efactory.EFactory with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore

generate eFactory "http://www.googlecode.com/efactory/EFactory"

Factory :
	(epackages+=PackageImport)*
	(imports+=Import)*
	(annotations+=Annotation)*
	root=NewObject;

	
PackageImport:
'use' ePackage = [ecore::EPackage|QualifiedName] '.*';
	// TODO like the *.Xtext grammar itself does, support namespace and package name based (try the 'import' above!) + maybe support an "as" syntax

// @deprecated.. once the index-based approach works & well tested, this may get removed completely..
Import :
	'import' (importURI=STRING // must be named 'importURI'
	)
;

Annotation:
	NameMapping
;

// TODO further consider if name mapping is best put in-line into objects.. it would have to repeat in every file..
// logically this rather belongs into an external mapping, like HUTN's Configuration (HutnConfig), or even better directly into an Xcore as annotations 
NameMapping:
	GlobalNameMapping | CustomNameMapping
;

GlobalNameMapping:
	"@Name" "{" nameFeature=ID "}"
;

CustomNameMapping:
	"@Name" "{" eClass=[ecore::EClass|QualifiedName] "=" nameFeature=[ecore::EAttribute] "}"
;
	
Feature:
	eFeature=[ecore::EStructuralFeature] "=" value=Value
;
	
NewObject:
	eClass=[ecore::EClass|QualifiedName] (name=ID)? "{"
		(features+=Feature)*
	"}";
	
Value:
	// The two (!) Syntactic Predicates => are needed here to solve "Decision can match input such as "RULE_ID '.' RULE_ID {RULE_STRING..RULE_DATE, '}', '['..'false'}" using multiple alternatives: 3, 4"
	MultiValue | Attribute | =>Containment | =>Reference 
;

MultiValue:
	({MultiValue} "[") (values += Value)* "]"
;

Reference:
	value = [ecore::EObject|QualifiedName] // NOT [NewObject]
;
	
Containment:
	value  = NewObject
;
	
Attribute:
	(EnumAttribute | StringAttribute | IntegerAttribute | BooleanAttribute | DoubleAttribute | DateAttribute | NullAttribute)
;

EnumAttribute:
	":" value = [ecore::EEnumLiteral]
;


StringAttribute :
	value=STRING
;

IntegerAttribute:
	value=LONG
;
	
DoubleAttribute:
	value=DOUBLE
;

DateAttribute:
	value=DATE
;

NullAttribute:
	value = "NULL"
;
	
BooleanAttribute:
	 value?="true" |  "false" {BooleanAttribute}
;	

QualifiedName:
  ValidID (=>'.' ValidID)*;
  
ValidID:
	ID;

terminal LONG returns ecore::ELong : ('-')?  ('0'..'9')+;
terminal DOUBLE returns ecore::EDouble : ('-')?  ('0'..'9')+ '.'  ('0'..'9')+;
terminal DATE returns ecore::EDate : ('0'..'1') '0'..'9' '.' '0'..'3' '0'..'9' '.'  '0'..'9' '0'..'9' '0'..'9' '0'..'9';
